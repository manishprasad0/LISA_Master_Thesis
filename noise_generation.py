# Expected LISA Instrumental Noise from the Test Masses and the Optical Metrology Subsystem (OMS)

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal.windows import hann
from scipy.signal import welch
import scipy as sp

def generate_noise(N, dt, sens_mat, seed=None, verification_plot=False, time_domain_plot = False, plot_lables=None):
    """
    Generate instrumental noise for LISA.
    
    Parameters:
    - dt: dt is the sampling interval, i.e., the time between two samples (The sampling rate would be 1/dt)
    - N: N is the number of samples in your original time-domain signal
    - sens_mat: Stock Sensitivity Models (eg. [A1TDISens, E1TDISens, T1TDISens])
    - seed: Random seed for the reproducibility of the noise generation
    - verification_plot: If True, it will plot the generated noise in frequency domain and compare it with the templates
    - time_domain_plot: If True, it will plot the generated noise in time domain
    - plot_lables: Labels for the plots
    
    Returns:
    - noise: Generated noise array
    """
    
    # set seed for reproducibility if given
    if seed is not None:
        np.random.seed(seed)

    # sens_mat has templates for the noise in the frequency domain. To generate the noise in the time domain, we need to convert it to the time domain.
    # The noise in the time domain is generated by taking the inverse Fourier transform of the noise in the frequency domain using np.fft.irfft
    # This generates a frequency dependent noise, which is colored noise (evenly distributed across all frequencies is white noise).

    noises = []
    for sens_fn in sens_mat.sens_mat:
        noise = np.fft.irfft(np.random.normal(0.0, np.sqrt(sens_fn))
                             +1j * np.random.normal(0.0, np.sqrt(sens_fn))
                            ) /np.sqrt(dt*4/N)  # Normalization factor
        noises.append(noise) 
    noises = np.array(noises)
    
    # To check if our generated noises are correct, conert them to frequency domain and plot them against our templates.
    if verification_plot:
        plot_noise(noises, dt, sens_mat, plot_lables=plot_lables)

    # Plot the generated noise in time domain if specified
    if time_domain_plot:
        time_vector = np.linspace(0, N*dt, N-1)
        for i in range(len(noises)):
            if plot_lables is None:
                plt.plot(time_vector, noises[i])
            else:
                plt.plot(time_vector, noises[i], label = plot_lables[i].removesuffix('TDISens'))
        plt.xlabel('Time (s)')
        plt.ylabel('Amplitude')
        plt.grid(True)
        plt.legend(loc = 'upper right')
        plt.show()

    return noises

def noise_time_to_freq_domain(noises, dt):
    """
    Convert the noise from time domain to frequency domain using Welch's method. 

    Parameters:
    - noise: Noise array signal to be added
    - dt: Sampling interval
    
    Returns:
    - noise: Generated noise array
    """

    fs = 1/dt
    win_length = int(len(noises[0]) / 4.5)
    window = hann(win_length)

    fout = []
    pxxout = []
    for noise in noises:
        f, pxx = welch(noise, window=window, noverlap=0, nfft=None, fs=fs, return_onesided=True)
        fout.append(f)
        pxxout.append(pxx)
    fout = np.array(fout)
    pxxout = np.array(pxxout)

    return fout, pxxout

def plot_noise(noises, dt, sens_mat, plot_lables=None):
    """
    Plot the generated noise.
    
    Parameters:
    - noises: Array of generated noise signals
    - dt: Sampling interval
    - sens_mat: Sensitivity matrix 
    - plot_lables: Labels for the plots
    """

    fout, pxxout = noise_time_to_freq_domain(noises, dt)

    plt.figure()
    for i in range(len(noises)):
        if plot_lables is None:
            plt.loglog(fout[i], np.sqrt(pxxout[i]))
            plt.loglog(sens_mat.frequency_arr, np.sqrt(sens_mat.sens_mat[i]))
        else:
            plt.loglog(fout[i], np.sqrt(pxxout[i]), label=plot_lables[i].removesuffix('TDISens'))
            plt.loglog(sens_mat.frequency_arr, np.sqrt(sens_mat.sens_mat[i]), label = plot_lables[i].removesuffix('TDISens') + ' Model')
        
    plt.xlabel('Frequency (Hz)')
    plt.ylabel(r'ASD [strain$/\sqrt{\mathrm{Hz}}$]')
    plt.grid(True, which='both')
    plt.legend(loc = 'lower left')
    plt.show()

def plot_spectogram(
        signal,
        dt,
        max_frequency = 0.1,
        min_frequency = 0.0001):

    f_mesh, t_mesh, sig_Z = sp.signal.stft(signal, 1/dt, nperseg=50000/dt)
    max_frequency_index = np.searchsorted(f_mesh, max_frequency)
    min_frequency_index = np.searchsorted(f_mesh, min_frequency)

    plt.figure()
    plt.pcolormesh(t_mesh, f_mesh[min_frequency_index:max_frequency_index], np.log(np.abs(sig_Z[min_frequency_index:max_frequency_index])), shading='gouraud')
    plt.colorbar()
    plt.xlabel('time (s)')
    plt.ylabel('frequency (Hz)')
    plt.yscale('log')
    
    #plt.ylim(min_frequency, 0.05)
    #from scipy.signal import spectrogram
    #spectrogram(wave_with_noise[0], fs=1.0/dt, window=('tukey', 0.25), nperseg=None, noverlap=None,mode='psd')
    #f, t, Sxx = spectrogram(wave_time_domain_with_noise[1], fs=1.0/dt, window=('tukey', 0.25), nperseg=200, mode='magnitude')
    #plt.pcolormesh(t, f, Sxx, shading='gouraud')
    #plt.ylabel('Frequency [Hz]')
    #plt.xlabel('Time [sec]')
    ##plt.yscale('log')
    #plt.ylim(1e-4, f[-1])
    #plt.show()